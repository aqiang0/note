# Java并发

### 1 线程和进程

#### 1.1 进程

进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，是系统运行程序的基本单位，因此进程是动态的

#### 1.2 线程

线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源，一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈

#### 1.3 线程与进程的关系

**根本区别**：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位

**开销方面**：每个进程都有独立的代码和数据空间（每个线程有自己的程序计数器、虚拟机栈和本地方法栈），进程之间切换开销大；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，线程之间切换的开销小

**所处环境**：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

**内存分配**：系统为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源

**包含关系**：线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程

#### 1.4 线程的生命周期和状态



![img](D:\note\Java并发.assets\20181219233801255)

**新建状态（New）**：当线程对象对创建后，即进入了新建状态，如：`Thread t = new MyThread();`

**就绪状态（Runnable）**：当调用线程对象的start()方法（`t.start();`），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了`t.start()`此线程立即就会执行；

**运行状态（Running）**：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；

**阻塞状态（Blocked）**：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：

1.等待阻塞：运行状态中的线程执行`wait()`方法，使本线程进入到等待阻塞状态；

2.同步阻塞 -- 线程在获取`synchronized`同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；

3.其他阻塞 -- 通过调用线程的`sleep()`或`join()`或发出了I/O请求时，线程会进入到阻塞状态。当`sleep()`状态超时、`join()`等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

**死亡状态（Dead）：**线程执行完了或者因异常退出了`run()`方法，该线程结束生命周期。

#### 1.5 线程死锁

线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态，

产生死锁必须具备以下四个条件：

**互斥条件**：该资源任意一个时刻只由一个线程占用。
**请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
**不剥夺条件:**线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
**循环等待条件**:若干进程之间形成一种头尾相接的循环等待资源关系。

#### 1.6 避免线程死锁

我们只要破坏产生死锁的四个条件中的其中一个就可以了：

**破坏互斥条件 ：**这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
**破坏请求与保持条件 ：**一次性申请所有的资源。
**破坏不剥夺条件 ：**占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
**破坏循环等待条件 ：**靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

### 2 程序计数器为什么是私有的?

程序计数器主要有下面两个作用：

- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
- 需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。

**所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。**

### 3 并发与并行

**并发：**一段时间内，多个任务交替执行

**并行：**一个时间点，同时执行多个任务

### 4  上下文切换

多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。

上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。

Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。

### 5  `sleep()` 方法和 `wait()` 方法区别和共同点

- 两者最主要的区别在于：**`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁**
- 两者都可以暂停线程的执行。
- `wait()` 通常被用于线程间交互/通信，`sleep()` 通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify() `或者 `notifyAll()` 方法。`sleep()` 方法执行完成后，线程会自动苏醒。或者可以使用 `wait(long timeout)` 超时后线程会自动苏醒。

